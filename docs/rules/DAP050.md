# DAP050

Multi-map queries (using `Query<T1, T2, TReturn>` with multiple type parameters and the `splitOn` parameter) are not currently supported by Dapper.AOT.

## What are multi-map queries?

Multi-map queries in Dapper allow you to map a single row to multiple objects based on a column delimiter. For example:

```csharp
var users = connection.Query<User, Address, User>(
    "SELECT * FROM Users U INNER JOIN Addresses A ON U.Id = A.UserId",
    (user, address) => {
        user.Address = address;
        return user;
    },
    splitOn: "Id");
```

The `splitOn` parameter tells Dapper which column marks the boundary between objects (default is "Id").

## Why isn't this supported?

Multi-map queries require complex runtime logic to:
- Split columns based on the `splitOn` parameter
- Read multiple objects from a single row
- Apply the mapping function to combine them

This functionality is planned for a future release of Dapper.AOT.

## Workarounds

Until multi-map support is added, you have several options:

### Option 1: Use manual mapping

Instead of relying on Dapper's multi-map feature, query all columns and manually map:

```csharp
public class UserWithAddress
{
    public int UserId { get; set; }
    public string UserName { get; set; }
    public int AddressId { get; set; }
    public string Street { get; set; }
    public string City { get; set; }
}

var results = connection.Query<UserWithAddress>(
    "SELECT U.Id as UserId, U.Name as UserName, A.Id as AddressId, A.Street, A.City " +
    "FROM Users U INNER JOIN Addresses A ON U.Id = A.UserId");

var users = results.Select(r => new User
{
    Id = r.UserId,
    Name = r.UserName,
    Address = new Address
    {
        Id = r.AddressId,
        Street = r.Street,
        City = r.City
    }
}).ToList();
```

### Option 2: Use multiple queries

Instead of joining in SQL, fetch related data separately:

```csharp
var users = connection.Query<User>("SELECT * FROM Users").ToList();
var addresses = connection.Query<Address>("SELECT * FROM Addresses").ToList();

// Manual joining in memory
foreach (var user in users)
{
    user.Address = addresses.FirstOrDefault(a => a.UserId == user.Id);
}
```

### Option 3: Disable Dapper.AOT for specific methods

If you need multi-map functionality, you can disable AOT for specific methods:

```csharp
[DapperAot(false)]
public IEnumerable<User> GetUsersWithAddresses(IDbConnection connection)
{
    return connection.Query<User, Address, User>(
        "SELECT * FROM Users U INNER JOIN Addresses A ON U.Id = A.UserId",
        (user, address) => {
            user.Address = address;
            return user;
        },
        splitOn: "Id");
}
```

Note: This will fall back to regular Dapper, which uses runtime code generation and is **not compatible with Native AOT scenarios**.

## Future Support

We're actively working on adding multi-map query support to Dapper.AOT. If this feature is important for your project, please [vote or comment on the issue](https://github.com/DapperLib/DapperAOT/issues) to help us prioritize development.
